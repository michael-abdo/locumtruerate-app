import { BaseExporter } from './base-exporter'
import { ExportResult, CSVExportOptions, ExportFormat } from './types'

export class CSVExporter extends BaseExporter {
  protected options: CSVExportOptions

  constructor(options: CSVExportOptions) {
    super(options)
    this.options = {
      delimiter: ',' as const,
      includeHeaders: true,
      quote: '"' as const,
      escape: '"',
      lineBreak: '\n' as const,
      encoding: 'utf-8' as const,
      ...options,
    }
  }

  async export(data: any): Promise<ExportResult> {
    try {
      const filename = this.generateFilename('csv')
      const csvContent = this.generateCSVContent(data)
      const blob = this.createBlob(csvContent, 'text/csv;charset=utf-8')

      return {
        success: true,
        filename,
        format: ExportFormat.CSV,
        size: blob.size,
        blob,
        url: this.createDownloadUrl(blob),
      }
    } catch (error) {
      return {
        success: false,
        filename: '',
        format: ExportFormat.CSV,
        size: 0,
        error: error instanceof Error ? error.message : 'CSV export failed',
      }
    }
  }

  private generateCSVContent(data: any): string {
    const sections = this.getSections(data)
    const rows: string[] = []

    // Add metadata
    rows.push(this.formatRow(['LocumTrueRate Export', this.formatDate(new Date())]))
    rows.push(this.formatRow(['', ''])) // Empty row

    // Process each section
    sections.forEach(section => {
      if (section.visible && section.data && Object.keys(section.data).length > 0) {
        // Section header
        rows.push(this.formatRow([section.title.toUpperCase(), '']))
        
        // Headers if enabled
        if (this.options.includeHeaders) {
          rows.push(this.formatRow(['Field', 'Value']))
        }

        // Data rows
        Object.entries(section.data).forEach(([key, value]) => {
          rows.push(this.formatRow([key, String(value)]))
        })

        // Empty row between sections
        rows.push(this.formatRow(['', '']))
      }
    })

    // Add calculation details if it's a detailed export
    if (data.calculations || data.formulas) {
      rows.push(this.formatRow(['CALCULATION DETAILS', '']))
      if (this.options.includeHeaders) {
        rows.push(this.formatRow(['Calculation', 'Formula', 'Result']))
      }

      // Tax calculations
      if (data.taxes && data.grossPay) {
        rows.push(this.formatRow([
          'Effective Tax Rate',
          `(Total Taxes / Gross Pay) * 100`,
          this.formatValue((data.taxes.total / data.grossPay) * 100, 'percentage')
        ]))
        
        rows.push(this.formatRow([
          'Take Home Percentage',
          `(Net Pay / Gross Pay) * 100`,
          this.formatValue((data.netPay / data.grossPay) * 100, 'percentage')
        ]))
      }

      // Contract calculations
      if (data.contractType && data.hourlyRate) {
        rows.push(this.formatRow([
          'Annual Equivalent',
          `Hourly Rate * Hours/Week * 52`,
          this.formatValue(data.annualEquivalent || 0, 'currency')
        ]))
      }
    }

    // Add comparison data if available
    if (this.options.includeComparison && data.comparison) {
      rows.push(this.formatRow(['', ''])) // Empty row
      rows.push(this.formatRow(['COMPARISON DATA', '']))
      
      if (Array.isArray(data.comparison)) {
        // Multiple items comparison
        const headers = ['Item', ...Object.keys(data.comparison[0] || {})]
        if (this.options.includeHeaders) {
          rows.push(this.formatRow(headers))
        }
        
        data.comparison.forEach((item: any, index: number) => {
          const values = [`Option ${index + 1}`, ...Object.values(item).map(v => String(v))]
          rows.push(this.formatRow(values))
        })
      } else {
        // Single comparison
        Object.entries(data.comparison).forEach(([key, value]) => {
          rows.push(this.formatRow([key, String(value)]))
        })
      }
    }

    // Footer
    rows.push(this.formatRow(['', ''])) // Empty row
    rows.push(this.formatRow(['Generated by LocumTrueRate.com', `Â© ${new Date().getFullYear()}`]))

    return rows.join(this.options.lineBreak)
  }

  private formatRow(cells: string[]): string {
    return cells.map(cell => this.formatCell(cell)).join(this.options.delimiter)
  }

  private formatCell(value: string): string {
    if (!value) return ''

    // Check if value needs to be quoted
    const needsQuoting = 
      value.includes(this.options.delimiter || ',') ||
      value.includes(this.options.quote || '"') ||
      value.includes('\n') ||
      value.includes('\r') ||
      value.startsWith(' ') ||
      value.endsWith(' ')

    if (!needsQuoting) {
      return value
    }

    // Escape quotes in the value
    const quote = this.options.quote || '"'
    const escape = this.options.escape || '"'
    const escaped = value.replace(
      new RegExp(quote, 'g'),
      escape + quote
    )

    // Wrap in quotes
    return `${quote}${escaped}${quote}`
  }

  // Static method for quick CSV export
  static async quickExport(data: any[], headers?: string[]): Promise<ExportResult> {
    const exporter = new CSVExporter({
      format: ExportFormat.CSV,
      includeHeaders: !!headers,
    })

    const csvData: any = {}
    
    if (headers && data.length > 0) {
      headers.forEach((header, index) => {
        csvData[header] = data.map(row => row[index] || '')
      })
    } else if (Array.isArray(data) && data.length > 0 && typeof data[0] === 'object') {
      // Convert array of objects to CSV format
      const keys = Object.keys(data[0])
      keys.forEach(key => {
        csvData[key] = data.map(item => item[key] || '')
      })
    }

    return exporter.export(csvData)
  }

  // Convert tabular data to CSV
  static tabularToCSV(
    data: any[][], 
    options?: Partial<CSVExportOptions>
  ): string {
    const opts = {
      delimiter: ',' as const,
      quote: '"' as const,
      escape: '"',
      lineBreak: '\n' as const,
      ...options,
    }

    const exporter = new CSVExporter({
      format: ExportFormat.CSV,
      ...opts,
    })

    return data.map(row => 
      row.map(cell => (exporter as any).formatCell(String(cell || ''))).join(opts.delimiter)
    ).join(opts.lineBreak)
  }
}